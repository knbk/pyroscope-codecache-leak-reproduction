/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    `java-library`
    `maven-publish`
}

import java.io.File as JFile
import java.util.zip.ZipFile

repositories {
    mavenLocal()
    maven {
        url = uri("https://repo.maven.apache.org/maven2/")
    }
}

dependencies {
    runtimeOnly(libs.io.pyroscope.agent)
    runtimeOnly(libs.tools.profiler.async.profiler)
}

group = "com.example.pyroscope"
version = "1.0-SNAPSHOT"
description = "pyroscope-codecache-leak-reproduction"
java.sourceCompatibility = JavaVersion.VERSION_21

// Ensure reproducible jar base name (pyroscope-codecache-leak-reproduction-*.jar)
base {
    archivesName.set("pyroscope-codecache-leak-reproduction")
}

tasks.jar {
    // Provide Main-Class so we can run with -cp or -jar if classpath is simple
    manifest {
        attributes["Main-Class"] = "com.example.pyroscope.Main"
    }
}

publishing {
    publications.create<MavenPublication>("maven") {
        from(components["java"])
    }
}

tasks.withType<JavaCompile>() {
    options.encoding = "UTF-8"
}

tasks.withType<Javadoc>() {
    options.encoding = "UTF-8"
}

// Copy agent runtime dependencies into build/agents with stable names for runner script
val copyAgents by tasks.registering(Copy::class) {
    val outDir = layout.buildDirectory.dir("agents")
    into(outDir)
    from(configurations.runtimeClasspath) {
        include("agent-*.jar")
        include("async-profiler-*.jar")
        eachFile {
            if (name.startsWith("agent-")) {
                // Rename agent-<ver>.jar -> pyroscope-agent-<ver>.jar
                name = name.replaceFirst("agent-", "pyroscope-agent-")
            }
        }
    }
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

tasks.build {
    dependsOn(copyAgents)
}

abstract class ExtractAsyncProfilerTask : DefaultTask() {
    @get:OutputDirectory
    val outputDir: DirectoryProperty = project.objects.directoryProperty()

    @TaskAction
    fun run() {
        val os = org.gradle.internal.os.OperatingSystem.current()
        val platform = when {
            os.isMacOsX -> "macos"
            os.isLinux -> "linux"
            else -> return
        }
        val arch = System.getProperty("os.arch").let {
            when (it) {
                "x86_64", "amd64" -> "x64"
                "aarch64", "arm64" -> "arm64"
                else -> "x64"
            }
        }
        val expectedPath = if (platform == "macos") "macos/libasyncProfiler.so" else "${platform}-${arch}/libasyncProfiler.so"
        val agentsDir = project.layout.buildDirectory.dir("agents").get().asFile
        val jar = agentsDir.listFiles()?.firstOrNull { it.name.startsWith("async-profiler-") }
            ?: throw GradleException("async-profiler jar not found in $agentsDir (copyAgents did not run?)")
        val out = outputDir.get().asFile
        out.mkdirs()
        ZipFile(jar).use { zf ->
            val entry = zf.getEntry(expectedPath) ?: throw GradleException("Entry $expectedPath missing in ${jar.name}")
            val target = JFile(out, "libasyncProfiler.so")
            zf.getInputStream(entry).use { input -> target.outputStream().use { output -> input.copyTo(output) } }
            target.setExecutable(true, false)
        }
        logger.lifecycle("Extracted async profiler native lib to ${out}/libasyncProfiler.so")
    }
}

val extractAsyncProfiler by tasks.registering(ExtractAsyncProfilerTask::class) {
    dependsOn(copyAgents)
    group = "build"
    description = "Extract async-profiler native library for current platform"
    val os = org.gradle.internal.os.OperatingSystem.current()
    val platform = when {
        os.isMacOsX -> "macos"
        os.isLinux -> "linux"
        else -> null
    }
    if (platform == null) {
        enabled = false
    } else {
        val arch = System.getProperty("os.arch").let {
            when (it) {
                "x86_64", "amd64" -> "x64"
                "aarch64", "arm64" -> "arm64"
                else -> "x64"
            }
        }
        outputDir.set(layout.buildDirectory.dir("async-profiler-extracted/${platform}-${arch}"))
    }
}

tasks.build {
    dependsOn(extractAsyncProfiler)
}